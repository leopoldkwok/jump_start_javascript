You can create an array in a couple of ways:

var myArray = new Array();

or:

var myArray = [];

Using the array literal, you can easily create a new array containing values such as the following:

var myArray = [4,8,15,16,23,42];

An array isn’t limited to numbers, though. You can also create an array with strings in it:

var fruit = ["apple", "orange", "pear", "grapes"];

Furthermore, you can mix the types of data stored in the array:

var stuff = [1, "apple", undefined, 42, "tanks", null, []];

Adding to an Array

var myArray = [];

myArray[0] = "Hello";
myArray[1] = "World";

It’s also possible to use named indices:

var myArray = [];

myArray["fruit"] = "apple";
myArray["vehicle"] = "tank";

This creates an associative array where items are stored by a named index rather than a numbered index. However, we'd discourage the use of associative arrays. The preferred way to store data with named indices is by using objects, which we’ll discuss in the next chapter.

there are a couple of ways to add data to an array. The second approach is to use the push method. This is useful in situations where you wish to add items to the end of an array, but want to avoid calculating the index required to access the final position. Instead, you can do this:

myArray.push("hello");

By using push, you simply add a new item to the existing array. If it’s an empty array, the data is written to position 0. If there are ten items in the array, the data is written to position 10 (remember, indices are zero-based).


Reading from an array is fairly straightforward. All you need to do is point to the item you want by its index number and the array will return it to you, like so:

var myValue,
	myArray = ["Hello", "World", "I", "am", "an", "array"];

	myValue = myArray[4]; // returns "an"

Nested Arrays

Sometimes, you’ll need to store an array within an array. Sometimes, you’ll require even more nesting. A quick warning: although it’s possible to nest a number of arrays, we advise against it, as working with many array indices can be confusing.
Let’s start with two simple arrays, which we’ll call yusuf and dreamers. We’ll fill dreamers with some values:

var yusuf, 
	dreamers;

yusuf = [];
dreamers = ["cobb", "arthur", "ariadne", "saito", "fischer"];

Now, reading any of the values from the dreamers array is as simple as passing in an index, which means placing the index value between a set of square brackets placed next to the array name. So, if we wanted "cobb", we’d pass in an index of 0:

var dreamer = dreamers[0]; // returns "cobb"

But what if dreamers wasn’t a named array but merely defined inline:

var yusuf;

yusuf = [["cobb", "arthur", "ariadne", "saito", "fischer"]];

How would we now get to "cobb"? By using: yusuf[0][0]. In the first square brackets, we'd define the index of the first array we want to read from; in the second set, we'd define the second index. 

So, reading "arthur" would be yusuf[0][1], "ariadne" would be yusuf[0][2], and so on.

var reality = ["yusuf", 
			  	["arthur", 
			  		["eames",
			  			["cobb", 
			  				"ariadne",
			  					"saito",
			  						"fischer"]
			  			]
			  		]
			  	];

Here, we have an outer array called reality. It contains the string "yusuf" and a nested array. The nested array contains the string "arthur" and another nested array, and so on. Reading values from this nested set would be as follows:

reality[0];
reality[1][0];
reality[1][1][0];
reality[1][1][1][0]; // returns "cobb"
reality[1][1][1][1]; // returns "ariadne"
reality[1][1][1][2]; // returns "saito"
reality[1][1][1][3]; // returns "fischer"

pop will remove the last element from the array and return it to you:

var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.pop(); // returns "Walk the dog"


push will add an item to the end of the array and return the array’s new length:
var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.push("Feed the cat"); // returns 4
// tasks is now:
// ["Pay phone bill",
//   "Write best-selling novel",
//   "Walk the dog",
//   "Feed the cat"]

reverse will reverse the order of the items in the array:
Arrays 31
var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.reverse();
// tasks is now:
// ["Walk the dog",
//   "Write best-selling novel",
//   "Pay phone bill"]

shift removes the first item in the array and returns it:
var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.shift(); // returns "Pay phone bill"
// tasks is now:
// ["Write best-selling novel",
//   "Walk the dog"]

var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.sort(); // sorts array in ascending order
// tasks is now:
// ["Pay phone bill",
//   "Walk the dog",
//   "Write best-selling novel"]

splice lets you perform selective surgery on an array, allowing you to simultan- eously add and remove items from an array with just one command:

var tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
tasks.splice(1, 1, "World domination");
// tasks is now:
// ["Pay phone bill",
//   "World domination",
//   "Walk the dog"]

We just told splice to start at the index of 1, which was the position of "Write best-selling novel",removeoneitem(removing"Write best-selling novel"), and then insert the item "World domination" in that position. We could do the same with multiple items:

  var tasks = [
            "Pay phone bill",
            "Write best-selling novel",
            "Walk the dog"
];
tasks.splice(1, 1, "World domination", "Rotate tires", ➥"Hire hit squad");
          // tasks is now:
          // ["Pay phone bill",
          // "World domination",
          // "Rotate tires",
          // "Hire hit squad",
          // "Walk the dog"]

Therearetwopointstonotehere.We’venowhavethreeitemswhere"Write best- selling novel" used to be, and the inserted items have shifted "Walk the dog" without overwriting it.
Of course, there’s no need to add any items when splicing. We could just remove items (and have them returned to us):

     var tasks, task;
          tasks = [
            "Pay phone bill",
            "Write best-selling novel",
            "Walk the dog"
];
task = tasks.splice(1, 1); ➥// returns "Write best-selling novel
          alert("REMINDER! Don’t forget to: " + task);
Here, all we’re doing is slicing out "Write best-selling novel" and storing it in the variable named task. We then trigger an alert with the message: "REMINDER! Don’t forget to: Write best-selling novel"

unshift adds one or more items to the beginning of the array and returns the array’s new length:
unshift.html (excerpt)
var tasks, len;
tasks = [
  "Pay phone bill",
  "Write best-selling novel",
  "Walk the dog"
];
len = tasks.unshift("Defeat nemesis", "Pick up dry
www.it-ebooks.info
Arrays 35
➥cleaning");
alert("You now have " + len + " tasks to complete: "
➥+ tasks.join(", "));

With concat, you can combine two or more arrays into one. The original arrays being concatenated remain untouched. The operation returns a newly formed array with the concatenated values in it:
￼
var arr1, arr2, arr3, arr4;
arr1 = ["Pay phone bill"];
arr2 = ["Write best-selling novel"];
arr3 = ["Walk the dog"];
arr4 = arr1.concat(arr2, arr3);
www.it-ebooks.info
36 Jump Start JavaScript
// arr4 contains:
// ["Pay phone bill",
//   "Write best-selling novel",
//   "walk the dog"]
Here, the concat method has filled arr4 with the contents of the first three arrays. The other three arrays remain unchanged, each still containing one item.


oin takes the values in an array and joins them into a string. You can pass it a parameter to specify what character(s) to put in between each item as it performs the join operation. If you don’t, it will just output a comma-separated list of items. Note that it doesn’t matter what type each of the array items are―join will perform a toString conversion on each item and use the result (we’ll look at toString in just a moment),

var nums;
          nums = [4, 8, 15, 16, 23, 42];
alert("The winning lottery numbers are: " ➥+ nums.join(", "));

slice will copy a part of an array and return it. Rather than modify the original array, it just makes a shallow copy. You tell it where to start and, optionally, where to end copying. So arr.slice(2) will return a copy of arr starting at index 2 and going all the way to the end of the array. Conversely, arr.slice(-2) will start at the end and give you the last two items. arr.slice(2, 4) will make a copy of arr from index 2 to index 4.

var tasks, todo, cleanup, noCleaning;
          tasks = [
                    "Fly a kite",
                    "Save the world",
                    [
                      "Clean bathroom",
                      "Clean garage",
                      "Clean up act"
] ];
          todo = tasks.slice(0); // makes a copy of tasks
          cleanup = tasks.slice(-1); // copies only the nested array
          noCleaning = tasks.slice(0, 2);
➥// copies only the first two items

The first point to note is that the third item in the tasks list is an array. We’ve already mentioned that slice makes a shallow copy of the array. This is an example of needing to be careful when making a sliced copy, because the child array will only be copied by reference. In other words, the copy of the child array will be pointing to the original, so if the original array changes, the copy will change too.

toString returns a string representing the array and its items:

var arr = ["These", "words", "are", ➥ "separated", "by", "commas"];
arr.toString(); //
➥returns "These,words,are,separated,by,commas"

When array items are exclusively strings, as in the previous example, they’re simply concatenated in a comma-separated list and returned. Numbers are first converted to strings before the concatenation:

var arr = ["These", 8, "words", "and", "numbers","are", "separated", "by", "commas"];

arr.toString(); // returns ➥"These,8,words,and,numbers,are,separated,by,commas"

When array items are exclusively strings, as in the previous example, they’re simply concatenated in a comma-separated list and returned. Numbers are first converted to strings before the concatenation:

var arr = ["These", 8 , "words", "and", "numbers", "are", "separated", "by", "commas"];

arr.toString(); // returns ➥"These,8,words,and,numbers,are,separated,by,commas"

In the case of arrays and objects (which we’ll cover later), we see a different behavior:

var arr = ["a","b","c", 100, 200, 300, [1,2,3], {"foo":"bar"}];

arr.toString(); // returns "a,b,c,100,200,300,1,2,3, ➥[object Object]"


Note how the toString function flattens out the nested array containing the values 1,2,3, but only outputs [object Object] for the object literal

indexOf will find the first instance of an item in an array and return its index to you. It does this using strict equality, just like when you use === instead of ==. Here's an example:

array.indexOf(searchElement, [fromIndex]);

The searchElement value is what you’re looking for. If you know that your value occurs after a certain point, you can optionally pass an index from which to begin the search so that you can avoid looking through the whole array, as shown below:

var alphabet;

alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i",  "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v",  "w", "x", "y", "z"];

alert("The letter 'm' is at index: " + alphabet.indexOf("m"));

You might pass in an index at which to start the search, like alphabet.indexOf("m", 10). In this case, there will be little difference as the number of items in the array is so small. But in very large arrays, it could have an impact on performance because you’ll have much fewer items to search through.

lastIndexOf works exactly like indexOf, but begins its search from the end of the array rather than the beginning. Thus, it will find the last occurrence of the searchElement:

array.lastIndexOf(searchElement, [fromIndex]);

Iteration Methods forEach

Traditionally, when you wanted to work with all the items in an array, you’d loop over it. Though we’ll be covering loops later, it’s important to show you how it used to be done so that you understand why the forEach method is handy.

The following is a program that uses the traditional method of looping over an array. The array contains a set of numbers, and on each pass, the instructions in the loop
www.it-ebooks.info
add the current number to the total. The program ends with an alert stating the total amount, which is 108:























